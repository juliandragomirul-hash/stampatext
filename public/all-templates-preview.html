<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>All Templates Preview</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: Arial, sans-serif; background: #f0f0f0; padding: 20px; }
  h1 { text-align: center; margin-bottom: 5px; }
  .subtitle { text-align: center; color: #666; margin-bottom: 20px; font-size: 14px; }
  .controls { text-align: center; margin-bottom: 20px; }
  .controls button {
    padding: 6px 14px; margin: 0 4px; border: 1px solid #999; border-radius: 4px;
    background: #fff; cursor: pointer; font-size: 13px;
  }
  .controls button.active { background: #333; color: #fff; border-color: #333; }
  .grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 16px;
  }
  .card {
    background: #fff;
    border: 2px solid #ddd;
    border-radius: 8px;
    padding: 10px;
    text-align: center;
    cursor: pointer;
    transition: border-color 0.15s, opacity 0.15s;
    position: relative;
  }
  .card:hover { border-color: #888; }
  .card.marked { border-color: #dc2626; opacity: 0.4; }
  .card.marked::after {
    content: 'REDUNDANT';
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: #dc2626; color: #fff; padding: 4px 12px; border-radius: 4px;
    font-weight: bold; font-size: 13px; pointer-events: none;
  }
  .card .name {
    font-size: 12px;
    font-weight: bold;
    color: #333;
    margin-bottom: 6px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .card .id-label {
    font-size: 10px;
    color: #aaa;
    margin-bottom: 4px;
  }
  .card .preview {
    width: 100%;
    height: 160px;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  .card .preview img {
    max-width: 100%;
    max-height: 160px;
  }
  .card .status {
    font-size: 10px;
    margin-top: 4px;
    color: #888;
  }
  .card .status.active { color: #16a34a; }
  .card .status.inactive { color: #dc2626; }
  .loading { text-align: center; padding: 40px; color: #888; font-size: 18px; }
  .summary {
    text-align: center; margin: 20px 0; padding: 12px;
    background: #fff; border-radius: 8px; font-size: 14px;
  }
  .summary .count { font-weight: bold; color: #333; }
  .summary .marked-count { font-weight: bold; color: #dc2626; }
  #marked-list {
    margin-top: 10px; font-size: 12px; color: #666;
    max-height: 200px; overflow-y: auto; text-align: left;
    display: none; padding: 10px; background: #fafafa; border-radius: 4px;
  }
  #marked-list.visible { display: block; }
</style>
</head>
<body>
<h1>All Templates Preview</h1>
<p class="subtitle">Click a template to mark it as redundant. Click again to unmark.</p>

<div class="controls">
  <input type="text" id="search-box" placeholder="Search by name..." oninput="searchCards(this.value)" style="padding:5px 10px;border:1px solid #999;border-radius:4px;font-size:13px;width:200px;">
  <span style="margin-left:8px;"></span>
  <button id="btn-all" class="active" onclick="filterCards('all')">All</button>
  <button id="btn-active" onclick="filterCards('active')">Active Only</button>
  <button id="btn-inactive" onclick="filterCards('inactive')">Inactive Only</button>
  <button id="btn-marked" onclick="filterCards('marked')">Marked Only</button>
  <span style="margin-left:16px;"></span>
  <button id="btn-toggle-list" onclick="toggleMarkedList()">Show Marked List</button>
  <button id="btn-clear" onclick="clearMarked()">Clear All Marks</button>
  <span style="margin-left:16px;"></span>
  <button id="btn-double-frame" onclick="toggleDoubleFrame()" style="border-color:#4f46e5;color:#4f46e5;">+ Double Frame</button>
  <button id="btn-rename-strip" onclick="stripButtonPrefix()" style="border-color:#d97706;color:#d97706;">Strip "Button" prefix</button>
</div>

<div class="summary">
  Total: <span class="count" id="total-count">--</span> |
  Active: <span class="count" id="active-count">--</span> |
  Inactive: <span class="count" id="inactive-count">--</span> |
  Marked redundant: <span class="marked-count" id="marked-count">0</span>
</div>
<div id="marked-list"></div>

<div class="loading" id="loading">Loading templates...</div>
<div class="grid" id="grid" style="display:none;"></div>

<script src="/js/supabase.umd.js"></script>
<script src="/js/config.js"></script>
<script src="/js/supabase-client.js"></script>
<script src="/js/svg-renderer.js"></script>
<script>
(async function() {
  var grid = document.getElementById('grid');
  var loading = document.getElementById('loading');
  var markedSet = new Set();
  var svgCache = {};       // id -> cleaned SVG string (after autoFit)
  var borderTypeCache = {}; // id -> { wavy, border, stitch, brush, filter }
  var doubleFrameOn = false;

  // Fetch ALL templates (active + inactive) with text zones
  var result = await sb
    .from('templates')
    .select('*, text_zones(*)')
    .order('name', { ascending: true });

  if (result.error) {
    loading.textContent = 'Error: ' + result.error.message;
    return;
  }

  var templates = result.data || [];
  var storageBaseUrl = sb.storage.from('templates').getPublicUrl('').data.publicUrl;

  // Sort templates by family grouping
  function getFamilyOrder(name) {
    var n = name.toLowerCase();
    if (n.indexOf('brushstroke') !== -1) return 1;
    if (n.indexOf('wavy') !== -1) return 2;
    if (n.indexOf('ripped') !== -1) return 3;
    if (n.indexOf('stitch line') !== -1) return 4;
    if (n.indexOf('stitch circle') !== -1) return 5;
    if (n.indexOf('stitch square') !== -1) return 6;
    if (n.indexOf('soft round') !== -1) return 7;
    if (n.indexOf('strong round') !== -1) return 8;
    if (n.indexOf('straight') !== -1) return 9;
    if (n.indexOf('strong perforated') !== -1) return 10;
    if (n.indexOf('spaced perforated') !== -1) return 11;
    if (n.indexOf('zigzag') !== -1) return 12;
    return 99;
  }
  function getVariantOrder(name) {
    var n = name.toLowerCase();
    if (n.indexOf('full') !== -1) return 0;
    if (n.indexOf('empty') !== -1) return 1;
    return 2;
  }
  templates.sort(function(a, b) {
    var fa = getFamilyOrder(a.name), fb = getFamilyOrder(b.name);
    if (fa !== fb) return fa - fb;
    var va = getVariantOrder(a.name), vb = getVariantOrder(b.name);
    if (va !== vb) return va - vb;
    return a.name.localeCompare(b.name);
  });

  var singles = templates.filter(function(t) { return !/double frame/i.test(t.name); });
  var doubles = templates.filter(function(t) { return /double frame/i.test(t.name); });
  document.getElementById('total-count').textContent = templates.length;
  document.getElementById('active-count').textContent = singles.length + ' singles, ' + doubles.length + ' doubles';
  document.getElementById('inactive-count').textContent = templates.filter(function(t) { return !t.is_active; }).length;

  loading.style.display = 'none';
  grid.style.display = 'grid';

  // Render all templates
  for (var i = 0; i < templates.length; i++) {
    var tpl = templates[i];
    var card = document.createElement('div');
    card.className = 'card';
    card.dataset.id = tpl.id;
    card.dataset.name = tpl.name;
    card.dataset.active = tpl.is_active ? 'true' : 'false';
    var isDouble = /double frame/i.test(tpl.name);
    card.dataset.frame = isDouble ? 'double' : 'single';
    if (isDouble) card.style.display = 'none'; // hide DB doubles by default
    // Hide Gentle Wavy — keeping only Strong Wavy (renamed to "Wavy")
    if (/gentle wavy/i.test(tpl.name)) card.style.display = 'none';
    // Hide Soft Perforated — ditched
    if (/soft perforated/i.test(tpl.name)) card.style.display = 'none';
    // Hide Soft Zigzag — ditched
    if (/soft zigzag/i.test(tpl.name)) card.style.display = 'none';
    // Renames
    var displayName = tpl.name.replace(/Strong Wavy/gi, 'Wavy');
    displayName = displayName.replace(/Strong Perforated Stamp/gi, 'Soft Perforated Postal Stamp');
    displayName = displayName.replace(/Spaced Perforated Stamp/gi, 'Strong Perforated Postal Stamp');

    card.innerHTML =
      '<div class="id-label">#' + (i + 1) + '</div>' +
      '<div class="name" title="' + escapeHtml(displayName) + '">' + escapeHtml(displayName) + '</div>' +
      '<div class="preview"><span style="color:#ccc;">Loading...</span></div>' +
      '<div class="status ' + (tpl.is_active ? 'active' : 'inactive') + '">' +
        (tpl.is_active ? 'Active' : 'Inactive') +
      '</div>';

    card.addEventListener('click', function() {
      var id = this.dataset.id;
      if (markedSet.has(id)) {
        markedSet.delete(id);
        this.classList.remove('marked');
      } else {
        markedSet.add(id);
        this.classList.add('marked');
      }
      updateMarkedCount();
    });

    grid.appendChild(card);

    // Load preview async (don't await — let them load in parallel)
    loadPreview(card, tpl, storageBaseUrl);
  }

  async function loadPreview(card, tpl, baseUrl) {
    var previewDiv = card.querySelector('.preview');
    if (!tpl.svg_path) {
      previewDiv.innerHTML = '<span style="color:#ccc;">No SVG</span>';
      return;
    }
    try {
      var svgUrl = baseUrl.replace(/\/$/, '') + '/' + tpl.svg_path;
      var svgString = await SvgRenderer.fetchSvg(svgUrl);
      var cleaned = SvgRenderer.cleanSvgString(svgString);
      // Replace default text with "APPROVED"
      cleaned = SvgRenderer.replaceTextInString(cleaned, 0, 'APPROVED');

      // Detect border type BEFORE autoFit strips data attributes
      borderTypeCache[tpl.id] = detectBorderType(cleaned);
      // Auto-fit using text zone data (same as gallery)
      var zones = tpl.text_zones || [];
      var didAutoFit = false;
      for (var idx = 0; idx < zones.length; idx++) {
        var zone = zones[idx];
        if (zone.bounding_width) {
          var origScaleX = zone.transform_matrix
            ? parseFloat((zone.transform_matrix.match(/matrix\(\s*([\d.]+)/) || [])[1]) || 1
            : 1;
          cleaned = await SvgRenderer.autoFitTextInString(
            cleaned, idx, zone.bounding_width, zone.font_size, origScaleX
          );
          didAutoFit = true;
        }
      }
      // Category 2 fallback
      if (!didAutoFit && /<image[\s>]/i.test(cleaned)) {
        cleaned = await SvgRenderer.autoFitTextInString(cleaned, 0, 1, 128, 1);
      }

      // Cache the cleaned SVG for double frame toggle
      svgCache[tpl.id] = cleaned;

      var display = doubleFrameOn ? addDoubleFrame(cleaned, borderTypeCache[tpl.id]) : cleaned;
      previewDiv.innerHTML = '';
      var img = SvgRenderer.createSvgImage(display);
      img.style.maxWidth = '100%';
      img.style.maxHeight = '160px';
      previewDiv.appendChild(img);

      // Generate Empty variant for Brushstroke Full
      if (/brushstroke.*full/i.test(tpl.name) && borderTypeCache[tpl.id] && borderTypeCache[tpl.id].brush) {
        var emptyCard = card.parentNode.querySelector('[data-name="Brushstroke Empty Single Frame"]');
        if (!emptyCard) {
          emptyCard = document.createElement('div');
          emptyCard.className = 'card';
          emptyCard.dataset.id = tpl.id + '-empty';
          emptyCard.dataset.name = 'Brushstroke Empty Single Frame';
          emptyCard.dataset.active = 'false';
          emptyCard.dataset.frame = 'single';
          emptyCard.innerHTML =
            '<div class="id-label">#1b</div>' +
            '<div class="name">Brushstroke Empty Single Frame</div>' +
            '<div class="preview"></div>' +
            '<div class="status inactive">Generated</div>';
          card.parentNode.insertBefore(emptyCard, card.nextSibling);
        }
        var emptySvg = makeBrushEmpty(cleaned);
        var emptyId = tpl.id + '-empty';
        // Cache empty SVG and borderInfo for double frame toggle
        svgCache[emptyId] = emptySvg;
        var fullBi = borderTypeCache[tpl.id];
        borderTypeCache[emptyId] = {
          wavy: fullBi.wavy, border: fullBi.border, stitch: fullBi.stitch,
          brush: fullBi.brush, brushCoords: fullBi.brushCoords, brushContent: fullBi.brushContent,
          filter: fullBi.filter,
          origFill: 'none',
          origStroke: fullBi.origFill || fullBi.origStroke,
          origStrokeWidth: fullBi.origStrokeWidth
        };
        var emptyDisplay = doubleFrameOn ? addDoubleFrame(emptySvg, borderTypeCache[emptyId]) : emptySvg;
        var emptyPreview = emptyCard.querySelector('.preview');
        emptyPreview.innerHTML = '';
        var emptyImg = SvgRenderer.createSvgImage(emptyDisplay);
        emptyImg.style.maxWidth = '100%';
        emptyImg.style.maxHeight = '160px';
        emptyPreview.appendChild(emptyImg);
      }
    } catch (err) {
      previewDiv.innerHTML = '<span style="color:#cc0000;font-size:11px;">Error</span>';
      console.error('Preview failed for', tpl.name, err);
    }
  }

  // Generate Brushstroke Empty from Full: remove red fill, add white center rect over brush
  function makeBrushEmpty(fullSvg) {
    var svg = fullSvg;
    // Find the colored (non-white) rect and set its fill to "none"
    var colorRectRe = /<rect([^>]*)fill=["']#(?!FFF)[A-Fa-f0-9]{6}["']([^>]*)>/i;
    var m = svg.match(colorRectRe);
    if (m) {
      // Extract rect dimensions for the white center
      var xM = m[0].match(/\bx=["']([\d.\-]+)["']/);
      var yM = m[0].match(/\by=["']([\d.\-]+)["']/);
      var wM = m[0].match(/\bwidth=["']([\d.]+)["']/);
      var hM = m[0].match(/\bheight=["']([\d.]+)["']/);
      var rx = xM ? parseFloat(xM[1]) : 0;
      var ry = yM ? parseFloat(yM[1]) : 0;
      var rw = wM ? parseFloat(wM[1]) : 0;
      var rh = hM ? parseFloat(hM[1]) : 0;
      // Extract the original fill color for text
      var fillColorM = m[0].match(/fill=["'](#[A-Fa-f0-9]{6})["']/);
      var rectColor = fillColorM ? fillColorM[1] : '#D42229';
      // Remove the colored rect fill
      svg = svg.replace(m[0], m[0].replace(/fill=["']#[A-Fa-f0-9]{6}["']/, 'fill="none"'));
      // Insert a white rect AFTER the brush group to mask the center
      var inset = 50;
      var whiteRect = '<rect x="' + (rx + inset).toFixed(2) + '" y="' + (ry + inset).toFixed(2) +
        '" width="' + (rw - inset * 2).toFixed(2) + '" height="' + (rh - inset * 2).toFixed(2) +
        '" fill="#FFFFFF"/>';
      // Place white rect just before <text
      var textPos = svg.search(/<text[\s>]/i);
      if (textPos !== -1) {
        svg = svg.slice(0, textPos) + whiteRect + svg.slice(textPos);
      }
      // Change text color to the original rect fill color
      svg = svg.replace(/(<text[^>]*fill=["'])#[A-Fa-f0-9]{6}(["'])/gi, '$1' + rectColor + '$2');
      svg = svg.replace(/(<tspan[^>]*fill=["'])#[A-Fa-f0-9]{6}(["'])/gi, '$1' + rectColor + '$2');
    }
    return svg;
  }

  // --- Detect border type from raw SVG (before autoFit strips data attributes) ---
  // Also caches original fill/stroke since autoFit wipes them for wavy/stitch
  function detectBorderType(svgStr) {
    // Find outer rect for original color extraction
    var rects = [];
    var re = /<rect([^>]*)\/?>/gi;
    var m;
    while ((m = re.exec(svgStr)) !== null) {
      var attrs = m[1];
      if (/fill=["'](?:#FFF(?:FFF)?|white)["']/i.test(attrs)) {
        var hasColoredStroke = /stroke=["'](?!none|#FFF|#FFFFFF|white)#?[A-Fa-f0-9]+["']/i.test(attrs);
        if (!hasColoredStroke) continue;
      }
      var wM = attrs.match(/\swidth=["']([\d.]+)["']/);
      if (!wM) continue;
      rects.push({ attrs: attrs, w: parseFloat(wM[1]) });
    }
    rects.sort(function(a, b) { return b.w - a.w; });

    var origFill = null, origStroke = null, origStrokeWidth = null;
    if (rects.length > 0) {
      var outerAttrs = rects[0].attrs;
      var fM = outerAttrs.match(/\bfill=["']([^"']+)["']/);
      var sM = outerAttrs.match(/\bstroke=["']([^"']+)["']/);
      var swM = outerAttrs.match(/stroke-width=["']([\d.]+)["']/);
      origFill = fM ? fM[1] : null;
      origStroke = sM ? sM[1] : null;
      origStrokeWidth = swM ? parseFloat(swM[1]) : null;
    }

    var wavyM = svgStr.match(/data-wavy=["']([^"']+)["']/);
    var borderM = svgStr.match(/data-border=["']([^"']+)["']/);
    var stitchM = svgStr.match(/data-stitch=["']([^"']+)["']/);
    var brushM = svgStr.match(/data-brush-border=["']([^"']+)["']/);
    var filterM = svgStr.match(/data-filter=["']([^"']+)["']/);

    // For brush borders, cache the original coords and the <use> content inside the group
    var brushCoords = null;
    var brushContent = null;
    if (brushM) {
      brushCoords = brushM[1].split(',').map(Number); // [x, y, w, h]
      var bgM = svgStr.match(/<g[^>]*data-brush-border=["'][^"']*["'][^>]*>([\s\S]*?)<\/g>/);
      if (bgM) brushContent = bgM[1].trim(); // e.g. '<use href="#bbp"/>'
    }

    return {
      wavy: wavyM ? wavyM[1] : null,
      border: borderM ? borderM[1] : null,
      stitch: stitchM ? stitchM[1] : null,
      brush: !!brushM,
      brushCoords: brushCoords,
      brushContent: brushContent,
      filter: filterM ? filterM[1] : null,
      origFill: origFill,
      origStroke: origStroke,
      origStrokeWidth: origStrokeWidth
    };
  }

  // --- Programmatic double frame injection ---
  function addDoubleFrame(svgStr, borderInfo) {
    // Skip Cat 2 (has <image>) — double frame only makes sense for Cat 1 (rect-based)
    // But if borderInfo already confirms a Cat 1 border type, trust that over <image> regex
    var bi = borderInfo || {};
    var isCat1Border = bi.wavy || bi.brush || bi.stitch || bi.border || bi.filter;
    if (!isCat1Border && /<image[\s>]/i.test(svgStr)) return svgStr;

    // Find the outer rect: largest non-white rect by width
    var rects = [];
    var re = /<rect([^>]*)\/?>/gi;
    var m;
    while ((m = re.exec(svgStr)) !== null) {
      var attrs = m[1];
      // Skip white background rects (but keep white-filled rects that have a colored stroke — those are empty frame rects)
      if (/fill=["'](?:#FFF(?:FFF)?|white)["']/i.test(attrs)) {
        var hasColoredStroke = /stroke=["'](?!none|#FFF|#FFFFFF|white)#?[A-Fa-f0-9]+["']/i.test(attrs);
        if (!hasColoredStroke) continue;
      }
      if (/display=["']none["']/i.test(attrs)) continue;
      var wM = attrs.match(/\swidth=["']([\d.]+)["']/);
      var hM = attrs.match(/\sheight=["']([\d.]+)["']/);
      if (!wM || !hM) continue;
      rects.push({
        full: m[0],
        attrs: attrs,
        w: parseFloat(wM[1]),
        h: parseFloat(hM[1]),
        index: m.index
      });
    }
    if (rects.length === 0) {
      return svgStr;
    }

    // Sort by width descending — outer rect is the widest
    rects.sort(function(a, b) { return b.w - a.w; });
    var outer = rects[0];

    // Check if this already has an inner rect (double frame template) — skip if so
    if (rects.length > 1 && rects[1].w > outer.w * 0.9) {
      var second = rects[1];
      if (/fill=["']none["']/i.test(second.attrs) && /stroke=["']#(?:FFF(?:FFF)?|FFFFFF)["']/i.test(second.attrs)) {
        return svgStr;
      }
    }

    // Parse outer rect attributes
    var xM = outer.attrs.match(/\bx=["']([\d.\-]+)["']/);
    var yM = outer.attrs.match(/\by=["']([\d.\-]+)["']/);
    var swM = outer.attrs.match(/stroke-width=["']([\d.]+)["']/);
    var rxM = outer.attrs.match(/\brx=["']([\d.]+)["']/);
    var ryM = outer.attrs.match(/\bry=["']([\d.]+)["']/);

    var ox = xM ? parseFloat(xM[1]) : 0;
    var oy = yM ? parseFloat(yM[1]) : 0;
    var ow = outer.w;
    var oh = outer.h;
    var osw = swM ? parseFloat(swM[1]) : (bi.origStrokeWidth || 20);
    if (osw === 0 && bi.origStrokeWidth) osw = bi.origStrokeWidth;
    var orx = rxM ? parseFloat(rxM[1]) : 0;
    var ory = ryM ? parseFloat(ryM[1]) : 0;

    // Detect if Full (has colored fill) or Empty (fill="none")
    // autoFit wipes fill/stroke for wavy (both → "none") and stitch (stroke removed)
    // so fall back to pre-cached original colors when post-autoFit values are degraded
    var fillM = outer.attrs.match(/\bfill=["']([^"']+)["']/);
    var outerFill = fillM ? fillM[1] : 'none';
    var strokeM = outer.attrs.match(/\bstroke=["']([^"']+)["']/);
    var outerStroke = strokeM ? strokeM[1] : '#000000';

    // Restore original colors only for border types where autoFit wipes fill/stroke
    // (wavy strips both, stitch strips stroke) — NOT for genuinely empty templates
    var autoFitWipesFill = bi.wavy;
    if (outerFill === 'none' && autoFitWipesFill && bi.origFill && bi.origFill !== 'none') {
      outerFill = bi.origFill;
    }
    if ((!strokeM || outerStroke === 'none') && bi.origStroke) {
      outerStroke = bi.origStroke;
    }

    // White fill is visually empty — treat as "not full" so inner rect uses stroke color
    var isFull = outerFill !== 'none' && !/^#(?:FFF(?:FFF)?|FFFFFF)$/i.test(outerFill);

    // Inner rect color: contrast (white/black) on Full, same as outer stroke on Empty
    var innerColor;
    if (isFull) {
      var hex = outerFill.replace('#', '');
      var r = parseInt(hex.substring(0, 2), 16);
      var g = parseInt(hex.substring(2, 4), 16);
      var b = parseInt(hex.substring(4, 6), 16);
      var lum = 0.299 * r + 0.587 * g + 0.114 * b;
      innerColor = lum > 160 ? '#000000' : '#FFFFFF';
    } else {
      // Empty: use outer stroke color, but never white (would be invisible)
      innerColor = outerStroke;
      if (!innerColor || innerColor === 'none' || /^#(?:FFF(?:FFF)?|FFFFFF)$/i.test(innerColor)) {
        innerColor = bi.origFill && bi.origFill !== 'none' ? bi.origFill : '#000000';
      }
    }

    // Inner rect sits in the visible interior, past the outer stroke's inner edge
    var innerSw = 12;
    var inset = osw / 2;
    // Stitch empty: stroke removed, stitch shapes are outside — inner rect sits close to edge
    if (bi.stitch && !isFull) inset = 12;
    // Brush templates: rect has no stroke, visual border is the brush group
    if (bi.brush) inset = Math.max(inset, Math.min(ow, oh) * 0.12);
    // Ripped paper empty: filter displaces edges, needs extra gap
    if (bi.filter && !isFull) inset = Math.max(inset, osw * 0.95);
    // Plain empty: same-color strokes need gap between them (Offset Path technique)
    // Minimum inset = outer half-stroke + inner half-stroke + visible gap
    // This preserves maximum corner radius while ensuring two distinct borders
    if (!isFull && !bi.wavy && !bi.brush && !bi.stitch && !bi.filter) {
      inset = osw / 2 + innerSw / 2 + 12;
    }
    var ix = ox + inset;
    var iy = oy + inset;
    var iw = ow - inset * 2;
    var ih = oh - inset * 2;
    // Offset Path: inner corner radius shrinks by inset (like Illustrator's Object > Path > Offset Path)
    var irx = Math.max(0, orx - inset);
    var iry = Math.max(0, ory - inset);

    // Build inner border
    var innerRect;
    if (bi.wavy) {
      // "Copy in place" technique: duplicate the outer wavy path with thinner white stroke
      // The thick outer stroke (40) with a thin white stroke (12) on top = double frame effect
      var wavyRe = /<path[^>]*stroke-linejoin="round"[^>]*\/?>/;
      var wavyMatch = svgStr.match(wavyRe);
      if (wavyMatch) {
        innerRect = wavyMatch[0]
          .replace(/fill="[^"]*"/, 'fill="none"')
          .replace(/stroke="[^"]*"/, 'stroke="#FFFFFF"')
          .replace(/stroke-width="[^"]*"/, 'stroke-width="12"');
      } else {
        return svgStr;
      }
    } else {
      // All other types: plain rect with Offset Path corner radius
      innerRect = '<rect x="' + ix.toFixed(2) + '" y="' + iy.toFixed(2) +
        '" width="' + iw.toFixed(2) + '" height="' + ih.toFixed(2) +
        '" fill="none" stroke="' + innerColor + '" stroke-width="' + innerSw +
        '" stroke-miterlimit="10"';
      if (irx > 0) innerRect += ' rx="' + irx.toFixed(1) + '"';
      if (iry > 0) innerRect += ' ry="' + iry.toFixed(1) + '"';
      innerRect += '/>';
    }

    // Inject inner border just before the first <text element
    var textPos = svgStr.search(/<text[\s>]/i);
    if (textPos !== -1) {
      return svgStr.slice(0, textPos) + innerRect + svgStr.slice(textPos);
    }
    return svgStr.replace(/<\/svg>/, innerRect + '</svg>');
  }


  // Toggle double frame on/off and re-render all previews
  window.toggleDoubleFrame = function() {
    doubleFrameOn = !doubleFrameOn;
    var btn = document.getElementById('btn-double-frame');
    if (doubleFrameOn) {
      btn.classList.add('active');
      btn.textContent = '- Double Frame';
    } else {
      btn.classList.remove('active');
      btn.textContent = '+ Double Frame';
    }
    // Re-render all cached previews
    grid.querySelectorAll('.card').forEach(function(card) {
      var id = card.dataset.id;
      var svg = svgCache[id];
      if (!svg) return;
      var display = doubleFrameOn ? addDoubleFrame(svg, borderTypeCache[id]) : svg;
      var previewDiv = card.querySelector('.preview');
      previewDiv.innerHTML = '';
      var img = SvgRenderer.createSvgImage(display);
      img.style.maxWidth = '100%';
      img.style.maxHeight = '160px';
      previewDiv.appendChild(img);
    });
  };

  // Strip "Button " prefix from all template names
  window.stripButtonPrefix = async function() {
    var btn = document.getElementById('btn-rename-strip');
    // Find templates with "Button " prefix
    var toRename = templates.filter(function(t) { return t.name.indexOf('Button ') === 0; });
    if (toRename.length === 0) { alert('No templates with "Button " prefix found.'); return; }
    if (!confirm('Rename ' + toRename.length + ' templates by removing "Button " prefix?')) return;
    btn.disabled = true;
    btn.textContent = 'Renaming...';
    var errors = [];
    for (var i = 0; i < toRename.length; i++) {
      var t = toRename[i];
      var newName = t.name.replace(/^Button\s+/, '');
      var res = await sb.from('templates').update({ name: newName }).eq('id', t.id);
      if (res.error) errors.push(t.name + ': ' + res.error.message);
    }
    if (errors.length > 0) {
      alert('Some renames failed:\n' + errors.join('\n'));
    } else {
      alert('Renamed ' + toRename.length + ' templates. Reloading...');
      location.reload();
    }
  };

  function updateMarkedCount() {
    document.getElementById('marked-count').textContent = markedSet.size;
    // Update marked list
    var listDiv = document.getElementById('marked-list');
    if (markedSet.size === 0) {
      listDiv.innerHTML = '<em>No templates marked.</em>';
      return;
    }
    var items = [];
    markedSet.forEach(function(id) {
      var card = grid.querySelector('[data-id="' + id + '"]');
      if (card) items.push(card.dataset.name);
    });
    items.sort();
    listDiv.innerHTML = '<strong>Marked as redundant (' + items.length + '):</strong><br>' +
      items.map(function(n) { return '&bull; ' + escapeHtml(n); }).join('<br>');
  }

  window.filterCards = function(filter) {
    document.querySelectorAll('.controls button').forEach(function(b) { b.classList.remove('active'); });
    document.getElementById('btn-' + filter).classList.add('active');
    grid.querySelectorAll('.card').forEach(function(card) {
      // Always hide DB doubles (they'll be generated programmatically)
      if (card.dataset.frame === 'double') { card.style.display = 'none'; return; }
      var show = true;
      if (filter === 'active') show = card.dataset.active === 'true';
      else if (filter === 'inactive') show = card.dataset.active === 'false';
      else if (filter === 'marked') show = card.classList.contains('marked');
      card.style.display = show ? '' : 'none';
    });
  };

  window.toggleMarkedList = function() {
    var listDiv = document.getElementById('marked-list');
    listDiv.classList.toggle('visible');
    updateMarkedCount();
  };

  window.clearMarked = function() {
    markedSet.clear();
    grid.querySelectorAll('.card.marked').forEach(function(c) { c.classList.remove('marked'); });
    updateMarkedCount();
  };

  window.searchCards = function(query) {
    var q = query.toLowerCase().trim();
    grid.querySelectorAll('.card').forEach(function(card) {
      if (card.dataset.frame === 'double') { card.style.display = 'none'; return; }
      if (!q) { card.style.display = ''; return; }
      var name = (card.dataset.name || '').toLowerCase();
      card.style.display = name.indexOf(q) !== -1 ? '' : 'none';
    });
  };

  function escapeHtml(str) {
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  }
})();
</script>
</body>
</html>
