<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>StampaText - Product Details</title>
  <link rel="stylesheet" href="/css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>

  <!-- Header -->
  <header class="header">
    <a href="/" class="header-logo"><img src="/logo.png" alt="stampatext" class="header-logo-img"></a>
    <div class="header-actions" id="header-actions">
      <span class="header-credits" id="user-credits" style="display:none;">0 credits</span>
      <button class="btn btn-secondary btn-small" id="btn-login">Login</button>
      <button class="btn btn-primary btn-small" id="btn-signup">Sign Up</button>
      <a href="/app" class="btn btn-primary btn-small" id="btn-go-app" style="display:none;">Go to App</a>
    </div>
  </header>

  <!-- Product Details -->
  <section class="product-details">
    <a href="/" class="product-back" id="product-back">&larr; Back to gallery</a>

    <div class="product-layout">
      <!-- Left: Large preview -->
      <div class="product-preview" id="product-preview">
        <div class="stamp-loading">Loading preview...</div>
      </div>

      <!-- Right: Preferences sidebar -->
      <div class="product-sidebar">
        <h3 class="product-sidebar-title">Customize</h3>
        <div id="product-template-info" class="product-template-info" style="display:none; margin-bottom:12px; font-size:0.82rem; color:#666; line-height:1.6;"></div>

        <div class="filter-section">
          <div class="filter-section-header">
            <span class="filter-section-title">FONT</span>
          </div>
          <div class="font-picker" id="product-font-picker"></div>
        </div>

        <div class="filter-section">
          <div class="filter-section-header">
            <span class="filter-section-title">COLOR</span>
          </div>
          <div class="color-palette" id="product-color-palette"></div>
        </div>

        <div class="filter-section">
          <div class="filter-section-header">
            <span class="filter-section-title">TILT</span>
          </div>
          <div class="product-toggle-group" id="product-tilt-toggle">
            <button class="product-toggle-btn active" data-value="0">Straight</button>
            <button class="product-toggle-btn" data-value="-20">20 degrees</button>
          </div>
        </div>

        <div class="filter-section">
          <div class="filter-section-header">
            <span class="filter-section-title">TEXTURE</span>
          </div>
          <div class="font-picker" id="product-texture-picker"></div>
        </div>
      </div>
    </div>

    <!-- Description below image -->
    <div class="product-description" id="product-description">Loading...</div>

    <!-- Download options button -->
    <button class="btn btn-primary product-download-btn" id="btn-download-options">Download options</button>
  </section>

  <!-- Download Modal -->
  <div class="modal-overlay" id="download-modal">
    <div class="modal" style="max-width:480px;">
      <button class="modal-close" id="download-modal-close">&times;</button>
      <h3 class="modal-title">Download options</h3>

      <div class="filter-section">
        <div class="filter-section-header">
          <span class="filter-section-title">JPG (WHITE BACKGROUND)</span>
        </div>
        <div class="download-options">
          <label class="download-option-card">
            <input type="radio" name="download-choice" value="jpg-small">
            <span class="download-option-label">Small</span>
            <span class="download-option-size">up to 500 px</span>
          </label>
          <label class="download-option-card">
            <input type="radio" name="download-choice" value="jpg-medium" checked>
            <span class="download-option-label">Medium</span>
            <span class="download-option-size">up to 1000 px</span>
          </label>
          <label class="download-option-card">
            <input type="radio" name="download-choice" value="jpg-large">
            <span class="download-option-label">Large</span>
            <span class="download-option-size">up to 3000 px</span>
          </label>
        </div>
      </div>

      <div class="filter-section">
        <div class="filter-section-header">
          <span class="filter-section-title">TRANSPARENT PNG</span>
        </div>
        <div class="download-options">
          <label class="download-option-card">
            <input type="radio" name="download-choice" value="png-small">
            <span class="download-option-label">Small</span>
            <span class="download-option-size">up to 500 px</span>
          </label>
          <label class="download-option-card">
            <input type="radio" name="download-choice" value="png-medium">
            <span class="download-option-label">Medium</span>
            <span class="download-option-size">up to 1000 px</span>
          </label>
          <label class="download-option-card">
            <input type="radio" name="download-choice" value="png-large">
            <span class="download-option-label">Large</span>
            <span class="download-option-size">up to 3000 px</span>
          </label>
        </div>
      </div>

      <button class="btn btn-primary" id="btn-download-confirm" style="width:100%;margin-top:1rem;">Download</button>
    </div>
  </div>

  <!-- Scripts -->
  <script src="/js/supabase.umd.js"></script>
  <script src="/js/config.js"></script>
  <script src="/js/supabase-client.js"></script>
  <script src="/js/svg-renderer.js?v=41"></script>
  <script>
    (async function() {
      // ---- Constants ----
      var PALETTE_COLORS = [
        '#000000', '#8B0000', '#003366', '#2D572C', '#4B0082',
        '#FF0000', '#FF6600', '#1E90FF', '#FF1493', '#32CD32'
      ];

      var COLOR_NAMES = {
        '#000000': 'Black', '#8B0000': 'Dark Red', '#003366': 'Navy',
        '#2D572C': 'Forest Green', '#4B0082': 'Indigo',
        '#FF0000': 'Red', '#FF6600': 'Orange', '#1E90FF': 'Dodger Blue',
        '#FF1493': 'Hot Pink', '#32CD32': 'Lime Green'
      };

      var AVAILABLE_FONTS = [
        { key: 'Oswald',          label: 'Oswald' },
        { key: 'Montserrat',      label: 'Montserrat' },
        { key: 'Nunito',          label: 'Nunito' },
        { key: 'RobotoBlack',     label: 'Roboto Black' },
        { key: 'PlayfairDisplay', label: 'Playfair Display' },
        { key: 'Merriweather',    label: 'Merriweather' },
        { key: 'Bitter',          label: 'Bitter' },
        { key: 'Exo2',            label: 'Exo 2' },
        { key: 'Comfortaa',       label: 'Comfortaa' },
        { key: 'Raleway',         label: 'Raleway' }
      ];

      var FONT_WEIGHTS = {
        'Oswald': '500', 'Montserrat': '900', 'Nunito': '900',
        'RobotoBlack': '900', 'PlayfairDisplay': '700',
        'Merriweather': '900', 'Bitter': '700',
        'Exo2': '900', 'Comfortaa': '700', 'Raleway': '900'
      };

      var BORDER_LABELS = {
        wavy: 'wavy', brushstroke: 'brushstroke',
        stitch_line: 'stitch line', stitch_square: 'stitch square', stitch_circle: 'stitch dot',
        torn_edge: 'torn edge', perforated_spaced: 'spaced perforated',
        perforated: 'perforated', zigzag: 'zigzag'
      };

      var TEXTURE_OPTIONS = [
        { key: '', label: 'No texture' },
        { key: 'grungy', label: 'Grungy' },
        { key: 'worn', label: 'Worn' },
        { key: 'scratched', label: 'Scratched' },
        { key: 'speckled', label: 'Speckled' },
        { key: 'noise', label: 'Noise' }
      ];

      // Stored for font switching — re-runs autoFit with new font
      var rawCleanedSvg = null;
      var storedZones = [];
      var storedDisplayText = '';
      var initialBaseSvg = null; // First render's SVG — preserves stamp shape

      async function rebuildWithFont(fontKey) {
        if (!rawCleanedSvg) return baseSvg;
        var weight = FONT_WEIGHTS[fontKey] || '400';

        // Start from raw template, replace font-family + weight
        var svg = rawCleanedSvg.replace(/font-family=["']'?[^"']*'?["']/g,
          "font-family=\"'" + fontKey + "'\"");
        svg = svg.replace(/font-weight=["'][^"']*["']/g,
          'font-weight="' + weight + '"');

        // Replace text + auto-fit (same logic as initial load)
        var didAutoFit = false;
        for (var i = 0; i < storedZones.length; i++) {
          var zone = storedZones[i];
          var idx = zone.svg_element_index || 0;
          svg = SvgRenderer.replaceTextInString(svg, idx, storedDisplayText);

          if (zone.bounding_width) {
            var originalScaleX = zone.transform_matrix
              ? parseFloat(zone.transform_matrix.match(/matrix\(\s*([\d.]+)/)?.[1]) || 1
              : 1;
            svg = await SvgRenderer.autoFitTextInString(
              svg, idx, zone.bounding_width,
              zone.font_size, originalScaleX
            );
            didAutoFit = true;
          }
        }

        // Category 2 (Fixed Frame): always auto-fit using container rect
        if (!didAutoFit && /<image[\s>]/i.test(svg)) {
          svg = await SvgRenderer.autoFitTextInString(svg, 0, 1, 128, 1);
        }

        // Category 1 (Dynamic Frame): preserve initial stamp shape
        var isCat1 = !/<image[\s>]/i.test(svg);
        if (isCat1) {
          if (!initialBaseSvg) {
            // First render — store as the reference shape
            initialBaseSvg = svg;
          } else {
            // Transplant autoFit text into initial stamp shape
            var autoFitTexts = [];
            svg.replace(/<text[\s\S]*?<\/text>/gi, function(m) {
              autoFitTexts.push(m);
            });

            // Calculate Y offset to re-center text in the (taller) initial viewBox
            function vbCenter(s) {
              var m = s.match(/viewBox=["']\s*([\d.\-]+)\s+([\d.\-]+)\s+([\d.\-]+)\s+([\d.\-]+)/);
              if (!m) return null;
              return {
                x: parseFloat(m[1]) + parseFloat(m[3]) / 2,
                y: parseFloat(m[2]) + parseFloat(m[4]) / 2
              };
            }
            var cAuto = vbCenter(svg);
            var cInit = vbCenter(initialBaseSvg);

            if (cAuto && cInit) {
              var dx = cInit.x - cAuto.x;
              var dy = cInit.y - cAuto.y;
              if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {
                for (var j = 0; j < autoFitTexts.length; j++) {
                  autoFitTexts[j] = autoFitTexts[j].replace(
                    /transform=["']translate\(\s*([\d.\-]+)[,\s]+([\d.\-]+)\s*\)["']/,
                    function(_, tx, ty) {
                      return 'transform="translate(' +
                        (parseFloat(tx) + dx).toFixed(2) + ', ' +
                        (parseFloat(ty) + dy).toFixed(2) + ')"';
                    }
                  );
                }
              }
            }

            // Splice autoFit text into the initial stamp shape
            var ti = 0;
            svg = initialBaseSvg.replace(/<text[\s\S]*?<\/text>/gi, function() {
              return autoFitTexts[ti++] || '';
            });
          }
        }

        return svg;
      }

      var DOWNLOAD_SIZES = {
        'jpg-small':  { maxSize: 500,  scale: 1, format: 'jpeg', ext: 'jpg' },
        'jpg-medium': { maxSize: 1000, scale: 1, format: 'jpeg', ext: 'jpg' },
        'jpg-large':  { maxSize: 1000, scale: 3, format: 'jpeg', ext: 'jpg' },
        'png-small':  { maxSize: 500,  scale: 1, format: 'png',  ext: 'png' },
        'png-medium': { maxSize: 1000, scale: 1, format: 'png',  ext: 'png' },
        'png-large':  { maxSize: 1000, scale: 3, format: 'png',  ext: 'png' }
      };

      // ---- State ----
      var baseSvg = null;
      var currentSvg = null;
      var templateName = '';
      var templateBorderType = null;
      var templateFillType = 'full';
      var templateCornerType = null;
      var templateObjectType = 'stamp';
      var userText = '';
      var currentColor = '';
      var currentFont = '';
      var currentTilt = 0;
      var currentTexture = '';
      var currentFrame = 'single';
      var borderInfo = null;
      var isProcessing = false;

      // ---- Parse URL params ----
      var params = new URLSearchParams(window.location.search);
      var templateId = params.get('id');
      userText = params.get('text') || '';
      var colorParam = (params.get('color') || '').toUpperCase();
      currentColor = colorParam ? '#' + colorParam : '';
      currentFont = params.get('font') || '';
      currentTilt = parseInt(params.get('tilt'), 10) || 0;
      currentTexture = params.get('texture') || '';
      if (SvgRenderer._textureAliases[currentTexture]) {
        currentTexture = SvgRenderer._textureAliases[currentTexture];
      }
      currentFrame = params.get('frame') || 'single';

      if (!templateId) {
        document.getElementById('product-preview').innerHTML =
          '<div class="stamp-empty">No template ID provided. <a href="/">Go back</a></div>';
        return;
      }

      // Back link preserves text
      document.getElementById('product-back').href = '/?text=' + encodeURIComponent(userText);

      // ---- Fetch template ----
      var { data: tpl, error } = await sb
        .from('templates')
        .select('*, text_zones(*)')
        .eq('id', templateId)
        .eq('is_active', true)
        .single();

      if (error || !tpl) {
        document.getElementById('product-preview').innerHTML =
          '<div class="stamp-empty">Could not load this template. <a href="/">Go back</a></div>';
        return;
      }

      templateName = tpl.name;
      templateBorderType = tpl.border_type || null;
      templateFillType = tpl.fill_type || 'full';
      templateCornerType = tpl.corner_type || null;
      templateObjectType = tpl.object_type || 'stamp';
      document.title = 'StampaText - ' + templateName;

      // Show template properties
      var infoEl = document.getElementById('product-template-info');
      var borderLabel = {
        wavy: 'Wavy', brushstroke: 'Brushstroke', stitch_line: 'Stitch Line',
        stitch_square: 'Stitch Square', stitch_circle: 'Stitch Dot',
        torn_edge: 'Torn Edge', perforated_spaced: 'Spaced Perforated',
        perforated: 'Perforated', zigzag: 'Zigzag'
      }[templateBorderType] || 'Plain';
      var cornerLabel = {
        medium_round: 'Medium Round', soft_round: 'Soft Round', strong_round: 'Strong Round'
      }[templateCornerType] || 'Straight';
      var fillLabel = templateFillType === 'full' ? 'Filled' : 'Outlined';
      var frameLabel = (tpl.frame_type || 'single') === 'double' ? 'Double' : 'Single';
      infoEl.style.display = 'none';

      // ---- Fetch SVG from storage ----
      var storageBaseUrl = sb.storage.from('templates').getPublicUrl('').data.publicUrl;
      var svgUrl = storageBaseUrl.replace(/\/$/, '') + '/' + tpl.svg_path;
      var rawSvg = await SvgRenderer.fetchSvg(svgUrl);
      var cleanedSvg = SvgRenderer.cleanSvgString(rawSvg);

      // ---- Detect text case from original SVG ----
      var displayText = userText;
      (function() {
        var textMatch = cleanedSvg.match(/<text[^>]*>([\s\S]*?)<\/text>/i);
        if (textMatch) {
          var inner = textMatch[1].replace(/<[^>]*>/g, '');
          inner = inner.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"');
          var letters = inner.replace(/[^a-zA-Z]/g, '');
          if (letters.length > 0) {
            var upper = letters.replace(/[^A-Z]/g, '').length;
            var lower = letters.replace(/[^a-z]/g, '').length;
            if (upper > 0 && lower === 0) displayText = userText.toUpperCase();
            else if (lower > 0 && upper === 0) displayText = userText.toLowerCase();
          }
        }
      })();

      // ---- Store raw template for font switching ----
      storedZones = (tpl.text_zones || [])
        .filter(function(z) { return z.is_editable; })
        .sort(function(a, b) { return a.sort_order - b.sort_order; });
      storedDisplayText = displayText;
      rawCleanedSvg = cleanedSvg;

      // ---- Detect font + color, then build initial baseSvg via autoFit ----

      // Detect current font from SVG if not in URL
      if (!currentFont) {
        var fontMatch = cleanedSvg.match(/font-family=["']'?([^"']+)'?["']/);
        if (fontMatch) currentFont = fontMatch[1];
      }
      // Default to Oswald if not recognized
      if (!AVAILABLE_FONTS.some(function(f) { return f.key === currentFont; })) {
        currentFont = 'Oswald';
      }

      // If no color in URL, use first palette color
      if (!currentColor || PALETTE_COLORS.indexOf(currentColor) === -1) {
        currentColor = '#000000';
      }

      // Initial render: run autoFit with selected font
      baseSvg = await rebuildWithFont(currentFont);

      // ---- Build UI ----
      buildFontPicker();
      buildColorPalette();
      buildTexturePicker();
      setToggleState('product-tilt-toggle', String(currentTilt));
      await renderPreview();

      // ---- Event listeners ----

      // Font picker arrows
      document.getElementById('font-arrow-up').addEventListener('click', function() { cycleFont(-1); });
      document.getElementById('font-arrow-down').addEventListener('click', function() { cycleFont(1); });
      // Keyboard: up/down arrows when font display is focused
      document.getElementById('font-display').addEventListener('keydown', function(e) {
        if (e.key === 'ArrowUp') { e.preventDefault(); cycleFont(-1); }
        else if (e.key === 'ArrowDown') { e.preventDefault(); cycleFont(1); }
      });

      // Color palette: single-select
      document.getElementById('product-color-palette').addEventListener('click', function(e) {
        var swatch = e.target.closest('.color-swatch');
        if (!swatch) return;
        this.querySelectorAll('.color-swatch').forEach(function(s) {
          s.classList.remove('selected');
        });
        swatch.classList.add('selected');
        currentColor = swatch.dataset.color;
        renderPreview();
      });

      // Frame toggle
      // Tilt toggle
      document.getElementById('product-tilt-toggle').addEventListener('click', function(e) {
        var btn = e.target.closest('.product-toggle-btn');
        if (!btn) return;
        this.querySelectorAll('.product-toggle-btn').forEach(function(b) {
          b.classList.remove('active');
        });
        btn.classList.add('active');
        currentTilt = parseInt(btn.dataset.value, 10) || 0;
        renderPreview();
      });

      // Texture picker arrows
      document.getElementById('texture-arrow-up').addEventListener('click', function() { cycleTexture(-1); });
      document.getElementById('texture-arrow-down').addEventListener('click', function() { cycleTexture(1); });
      document.getElementById('texture-display').addEventListener('keydown', function(e) {
        if (e.key === 'ArrowUp') { e.preventDefault(); cycleTexture(-1); }
        else if (e.key === 'ArrowDown') { e.preventDefault(); cycleTexture(1); }
      });

      // Download modal open
      document.getElementById('btn-download-options').addEventListener('click', function() {
        document.getElementById('download-modal').classList.add('active');
      });

      // Download modal close
      document.getElementById('download-modal-close').addEventListener('click', function() {
        document.getElementById('download-modal').classList.remove('active');
      });

      // Click outside modal to close
      document.getElementById('download-modal').addEventListener('click', function(e) {
        if (e.target === this) this.classList.remove('active');
      });

      // Download confirm
      document.getElementById('btn-download-confirm').addEventListener('click', handleDownload);

      // ---- Helper functions ----

      function isColorDark(hex) {
        var c = hex.replace('#', '');
        var r = parseInt(c.substring(0, 2), 16);
        var g = parseInt(c.substring(2, 4), 16);
        var b = parseInt(c.substring(4, 6), 16);
        return (r * 0.299 + g * 0.587 + b * 0.114) < 150;
      }

      function buildFontPicker() {
        var picker = document.getElementById('product-font-picker');
        var btnUp = document.createElement('div');
        btnUp.className = 'font-picker-arrow';
        btnUp.id = 'font-arrow-up';
        btnUp.innerHTML = '&#9650;';
        var display = document.createElement('div');
        display.className = 'font-picker-display';
        display.id = 'font-display';
        display.tabIndex = 0;
        var btnDown = document.createElement('div');
        btnDown.className = 'font-picker-arrow';
        btnDown.id = 'font-arrow-down';
        btnDown.innerHTML = '&#9660;';
        picker.appendChild(btnUp);
        picker.appendChild(display);
        picker.appendChild(btnDown);
        updateFontDisplay();
      }

      function getFontIndex() {
        for (var i = 0; i < AVAILABLE_FONTS.length; i++) {
          if (AVAILABLE_FONTS[i].key === currentFont) return i;
        }
        return 0;
      }

      function updateFontDisplay() {
        var idx = getFontIndex();
        var font = AVAILABLE_FONTS[idx];
        var display = document.getElementById('font-display');
        display.textContent = font.label.toUpperCase();
        display.style.fontFamily = "'" + font.key + "', 'Arial Black', sans-serif";
      }

      function cycleFont(dir) {
        var idx = getFontIndex();
        idx = (idx + dir + AVAILABLE_FONTS.length) % AVAILABLE_FONTS.length;
        currentFont = AVAILABLE_FONTS[idx].key;
        updateFontDisplay();
        renderPreview();
      }

      // ---- Texture picker (arrow-based, same pattern as font) ----
      function buildTexturePicker() {
        var picker = document.getElementById('product-texture-picker');
        var btnUp = document.createElement('div');
        btnUp.className = 'font-picker-arrow';
        btnUp.id = 'texture-arrow-up';
        btnUp.innerHTML = '&#9650;';
        var display = document.createElement('div');
        display.className = 'font-picker-display';
        display.id = 'texture-display';
        display.tabIndex = 0;
        var btnDown = document.createElement('div');
        btnDown.className = 'font-picker-arrow';
        btnDown.id = 'texture-arrow-down';
        btnDown.innerHTML = '&#9660;';
        picker.appendChild(btnUp);
        picker.appendChild(display);
        picker.appendChild(btnDown);
        updateTextureDisplay();
      }

      function getTextureIndex() {
        for (var i = 0; i < TEXTURE_OPTIONS.length; i++) {
          if (TEXTURE_OPTIONS[i].key === currentTexture) return i;
        }
        return 0;
      }

      function updateTextureDisplay() {
        var idx = getTextureIndex();
        var display = document.getElementById('texture-display');
        display.textContent = TEXTURE_OPTIONS[idx].label;
      }

      function cycleTexture(dir) {
        var idx = getTextureIndex();
        idx = (idx + dir + TEXTURE_OPTIONS.length) % TEXTURE_OPTIONS.length;
        currentTexture = TEXTURE_OPTIONS[idx].key;
        updateTextureDisplay();
        renderPreview();
      }

      function buildColorPalette() {
        var palette = document.getElementById('product-color-palette');
        PALETTE_COLORS.forEach(function(color) {
          var swatch = document.createElement('div');
          swatch.className = 'color-swatch';
          if (isColorDark(color)) swatch.classList.add('swatch-dark');
          swatch.style.backgroundColor = color;
          swatch.dataset.color = color;
          if (color === '#FFFFFF') {
            swatch.style.border = '2px solid #d4d4d4';
          }
          if (color.toUpperCase() === currentColor.toUpperCase()) {
            swatch.classList.add('selected');
          }
          palette.appendChild(swatch);
        });
      }

      function setToggleState(containerId, value) {
        var container = document.getElementById(containerId);
        container.querySelectorAll('.product-toggle-btn').forEach(function(btn) {
          btn.classList.toggle('active', btn.dataset.value === value);
        });
      }

      function detectBorderType(svgStr) {
        var rects = [];
        var re = /<rect([^>]*)\/?>/gi;
        var m;
        while ((m = re.exec(svgStr)) !== null) {
          var attrs = m[1];
          if (/fill=["'](?:#FFF(?:FFF)?|white)["']/i.test(attrs)) {
            var hasColoredStroke = /stroke=["'](?!none|#FFF|#FFFFFF|white)#?[A-Fa-f0-9]+["']/i.test(attrs);
            if (!hasColoredStroke) continue;
          }
          var wM = attrs.match(/\swidth=["']([\d.]+)["']/);
          if (!wM) continue;
          rects.push({ attrs: attrs, w: parseFloat(wM[1]) });
        }
        rects.sort(function(a, b) { return b.w - a.w; });
        var origFill = null, origStroke = null, origStrokeWidth = null;
        if (rects.length > 0) {
          var outerAttrs = rects[0].attrs;
          var fM = outerAttrs.match(/\bfill=["']([^"']+)["']/);
          var sM = outerAttrs.match(/\bstroke=["']([^"']+)["']/);
          var swM = outerAttrs.match(/stroke-width=["']([\d.]+)["']/);
          origFill = fM ? fM[1] : null;
          origStroke = sM ? sM[1] : null;
          origStrokeWidth = swM ? parseFloat(swM[1]) : null;
        }
        var wavyM = svgStr.match(/data-wavy=["']([^"']+)["']/);
        var borderM = svgStr.match(/data-border=["']([^"']+)["']/);
        var stitchM = svgStr.match(/data-stitch=["']([^"']+)["']/);
        var brushM = svgStr.match(/data-brush-border=["']([^"']+)["']/);
        var filterM = svgStr.match(/data-filter=["']([^"']+)["']/);
        var brushCoords = null, brushContent = null;
        if (brushM) {
          brushCoords = brushM[1].split(',').map(Number);
          var bgM = svgStr.match(/<g[^>]*data-brush-border=["'][^"']*["'][^>]*>([\s\S]*?)<\/g>/);
          if (bgM) brushContent = bgM[1].trim();
        }
        return {
          wavy: wavyM ? wavyM[1] : null,
          border: borderM ? borderM[1] : null,
          stitch: stitchM ? stitchM[1] : null,
          brush: !!brushM,
          brushCoords: brushCoords,
          brushContent: brushContent,
          filter: filterM ? filterM[1] : null,
          origFill: origFill,
          origStroke: origStroke,
          origStrokeWidth: origStrokeWidth
        };
      }

      async function renderPreview() {
        if (isProcessing) return;
        isProcessing = true;

        var previewEl = document.getElementById('product-preview');
        previewEl.style.opacity = '0.5';

        try {
          // Rebuild from raw template with current font (autoFit handles sizing)
          baseSvg = await rebuildWithFont(currentFont);
          var svg = baseSvg;
          svg = SvgRenderer.colorize(svg, currentColor);
          svg = SvgRenderer.applyCornerRadius(svg, templateCornerType);
          svg = await SvgRenderer.cropViewBoxFixedFrame(svg);
          if (currentFrame === 'double') {
            if (!borderInfo) borderInfo = detectBorderType(rawCleanedSvg);
            var dblBi = Object.assign({}, borderInfo);
            SvgRenderer.supplementBorderInfo(dblBi, { border_type: templateBorderType, fill_type: templateFillType });
            svg = SvgRenderer.addDoubleFrame(svg, dblBi, currentColor);
          } else if (currentFrame === 'split') {
            if (!borderInfo) borderInfo = detectBorderType(rawCleanedSvg);
            var ifBi = Object.assign({}, borderInfo);
            SvgRenderer.supplementBorderInfo(ifBi, { border_type: templateBorderType, fill_type: templateFillType });
            svg = SvgRenderer.addSplitBorder(svg, ifBi);
          }
          // Capture pre-tilt viewBox width for scale compensation
          var preTiltVbW = 0;
          var preTiltMatch = svg.match(/viewBox=["']\s*[\d.\-]+\s+[\d.\-]+\s+([\d.\-]+)\s+[\d.\-]+\s*["']/);
          if (preTiltMatch) preTiltVbW = parseFloat(preTiltMatch[1]);

          if (currentTilt !== 0) {
            svg = SvgRenderer.applyTilt(svg, currentTilt);
          }
          if (currentTexture) {
            svg = await SvgRenderer.applyTexture(svg, currentTexture);
          }

          currentSvg = svg;

          previewEl.innerHTML = '';
          var img = SvgRenderer.createSvgImage(svg);

          // Compensate for viewBox expansion from tilt so preview stays same visual size
          if (currentTilt !== 0 && preTiltVbW > 0) {
            var postTiltMatch = svg.match(/viewBox=["']\s*[\d.\-]+\s+[\d.\-]+\s+([\d.\-]+)\s+[\d.\-]+\s*["']/);
            if (postTiltMatch) {
              var postTiltVbW = parseFloat(postTiltMatch[1]);
              var scaleFactor = postTiltVbW / preTiltVbW;
              img.querySelector('svg').style.transform = 'scale(' + scaleFactor.toFixed(4) + ')';
            }
          }
          previewEl.appendChild(img);

          updateDescription();
          updateUrl();
        } catch (err) {
          console.error('Preview render error:', err);
        } finally {
          previewEl.style.opacity = '1';
          isProcessing = false;
        }
      }

      function updateDescription() {
        var colorName = getColorName(currentColor);
        var border = BORDER_LABELS[templateBorderType] || 'plain';
        var fill = (templateFillType === 'empty') ? 'outlined' : 'filled';
        var texture = '';
        if (currentTexture) {
          var resolved = SvgRenderer._textureAliases[currentTexture] || currentTexture;
          var preset = SvgRenderer._texturePresets[resolved];
          texture = preset ? preset.label.toLowerCase() : '';
        }
        var tilt = (currentTilt && currentTilt !== 0) ? 'tilted' : '';
        var frame = '';
        if (currentFrame === 'double') frame = 'double border';
        else if (currentFrame === 'split') frame = 'split border';
        var shape = 'rectangle';
        if (currentSvg) {
          var vbM = currentSvg.match(/viewBox=["']\s*[\d.\-]+\s+[\d.\-]+\s+([\d.\-]+)\s+([\d.\-]+)/);
          if (vbM) {
            var ratio = parseFloat(vbM[1]) / parseFloat(vbM[2]);
            if (ratio >= 0.85 && ratio <= 1.15) shape = 'square';
          }
        }
        var obj = (shape + ' ' + (templateObjectType || 'stamp')).replace(/_/g, ' ');
        var corners = 'straight corners';
        if (templateCornerType === 'strong_round') corners = 'strong round corners';
        else if (templateCornerType === 'medium_round') corners = 'medium round corners';
        else if (templateCornerType === 'soft_round') corners = 'soft round corners';
        var adjectives = [tilt, border, frame].filter(Boolean).join(' ');
        var objPhrase = (adjectives ? adjectives + ' ' : '') + obj;
        var withParts = [corners, texture ? texture + ' texture' : ''].filter(Boolean);
        var withClause = withParts.length ? ' with ' + withParts.join(' and ') : '';
        var desc = '\u201C' + displayText + '\u201D written on ' +
          fill + ' ' + colorName.toLowerCase() + ' ' + objPhrase + withClause;
        document.getElementById('product-description').textContent = desc;
      }

      function updateUrl() {
        var newUrl = '/product.html?id=' + encodeURIComponent(templateId) +
          '&text=' + encodeURIComponent(userText) +
          '&color=' + encodeURIComponent(currentColor.replace('#', '')) +
          '&font=' + encodeURIComponent(currentFont) +
          '&frame=' + encodeURIComponent(currentFrame) +
          '&tilt=' + encodeURIComponent(currentTilt) +
          (currentTexture ? '&texture=' + encodeURIComponent(currentTexture) : '');
        window.history.replaceState(null, '', newUrl);
      }

      function getColorName(hex) {
        return COLOR_NAMES[(hex || '').toUpperCase()] || hex;
      }

      async function handleDownload() {
        var selected = document.querySelector('input[name="download-choice"]:checked');
        if (!selected) {
          alert('Please select a download size.');
          return;
        }

        var choice = selected.value;
        var config = DOWNLOAD_SIZES[choice];
        if (!config || !currentSvg) return;

        var btn = document.getElementById('btn-download-confirm');
        btn.disabled = true;
        btn.textContent = 'Preparing...';

        try {
          var blob = await SvgRenderer.exportImage(
            currentSvg, config.maxSize, null, config.scale, config.format
          );
          var filename = 'stampatext-' + Date.now() + '.' + config.ext;
          SvgRenderer.downloadBlob(blob, filename);

          document.getElementById('download-modal').classList.remove('active');
        } catch (err) {
          console.error('Download error:', err);
          alert('Download failed: ' + err.message);
        } finally {
          btn.disabled = false;
          btn.textContent = 'Download';
        }
      }

    })();
  </script>

</body>
</html>
