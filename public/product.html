<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>StampaText - Product Details</title>
  <link rel="stylesheet" href="/css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>

  <!-- Header -->
  <header class="header">
    <a href="/" class="header-logo"><img src="/logo.png" alt="stampatext" class="header-logo-img"></a>
    <div class="header-actions" id="header-actions">
      <span class="header-credits" id="user-credits" style="display:none;">0 credits</span>
      <button class="btn btn-secondary btn-small" id="btn-login">Login</button>
      <button class="btn btn-primary btn-small" id="btn-signup">Sign Up</button>
      <a href="/app" class="btn btn-primary btn-small" id="btn-go-app" style="display:none;">Go to App</a>
    </div>
  </header>

  <!-- Product Details -->
  <section class="product-details">
    <a href="/" class="product-back" id="product-back">&larr; Back to gallery</a>

    <div class="product-layout">
      <!-- Left: Large preview -->
      <div class="product-preview" id="product-preview">
        <div class="stamp-loading">Loading preview...</div>
      </div>

      <!-- Right: Preferences sidebar -->
      <div class="product-sidebar">
        <h3 class="product-sidebar-title">Customize</h3>

        <div class="filter-section">
          <div class="filter-section-header">
            <span class="filter-section-title">FONT</span>
          </div>
          <div class="font-picker" id="product-font-picker"></div>
        </div>

        <div class="filter-section">
          <div class="filter-section-header">
            <span class="filter-section-title">COLOR</span>
          </div>
          <div class="color-palette" id="product-color-palette"></div>
        </div>

        <div class="filter-section">
          <div class="filter-section-header">
            <span class="filter-section-title">FRAME</span>
          </div>
          <div class="product-toggle-group" id="product-frame-toggle">
            <button class="product-toggle-btn active" data-value="single">Single</button>
            <button class="product-toggle-btn" data-value="double">Double</button>
          </div>
        </div>

        <div class="filter-section">
          <div class="filter-section-header">
            <span class="filter-section-title">TILT</span>
          </div>
          <div class="product-toggle-group" id="product-tilt-toggle">
            <button class="product-toggle-btn active" data-value="0">Straight</button>
            <button class="product-toggle-btn" data-value="-20">20 degrees</button>
          </div>
        </div>

        <div class="filter-section">
          <div class="filter-section-header">
            <span class="filter-section-title">TEXTURE</span>
          </div>
          <div class="product-toggle-group" id="product-texture-toggle">
            <button class="product-toggle-btn active" data-value="">No texture</button>
            <button class="product-toggle-btn" data-value="grungy_texture">Grungy</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Description below image -->
    <div class="product-description" id="product-description">Loading...</div>

    <!-- Download options button -->
    <button class="btn btn-primary product-download-btn" id="btn-download-options">Download options</button>
  </section>

  <!-- Download Modal -->
  <div class="modal-overlay" id="download-modal">
    <div class="modal" style="max-width:480px;">
      <button class="modal-close" id="download-modal-close">&times;</button>
      <h3 class="modal-title">Download options</h3>

      <div class="filter-section">
        <div class="filter-section-header">
          <span class="filter-section-title">JPG (WHITE BACKGROUND)</span>
        </div>
        <div class="download-options">
          <label class="download-option-card">
            <input type="radio" name="download-choice" value="jpg-small">
            <span class="download-option-label">Small</span>
            <span class="download-option-size">up to 500 px</span>
          </label>
          <label class="download-option-card">
            <input type="radio" name="download-choice" value="jpg-medium" checked>
            <span class="download-option-label">Medium</span>
            <span class="download-option-size">up to 1000 px</span>
          </label>
          <label class="download-option-card">
            <input type="radio" name="download-choice" value="jpg-large">
            <span class="download-option-label">Large</span>
            <span class="download-option-size">up to 3000 px</span>
          </label>
        </div>
      </div>

      <div class="filter-section">
        <div class="filter-section-header">
          <span class="filter-section-title">TRANSPARENT PNG</span>
        </div>
        <div class="download-options">
          <label class="download-option-card">
            <input type="radio" name="download-choice" value="png-small">
            <span class="download-option-label">Small</span>
            <span class="download-option-size">up to 500 px</span>
          </label>
          <label class="download-option-card">
            <input type="radio" name="download-choice" value="png-medium">
            <span class="download-option-label">Medium</span>
            <span class="download-option-size">up to 1000 px</span>
          </label>
          <label class="download-option-card">
            <input type="radio" name="download-choice" value="png-large">
            <span class="download-option-label">Large</span>
            <span class="download-option-size">up to 3000 px</span>
          </label>
        </div>
      </div>

      <button class="btn btn-primary" id="btn-download-confirm" style="width:100%;margin-top:1rem;">Download</button>
    </div>
  </div>

  <!-- Scripts -->
  <script src="/js/supabase.umd.js"></script>
  <script src="/js/config.js"></script>
  <script src="/js/supabase-client.js"></script>
  <script src="/js/svg-renderer.js?v=40"></script>
  <script>
    (async function() {
      // ---- Constants ----
      var PALETTE_COLORS = [
        '#000000', '#8B0000', '#003366', '#2D572C', '#4B0082',
        '#FF0000', '#FF6600', '#1E90FF', '#FF1493', '#32CD32'
      ];

      var COLOR_NAMES = {
        '#000000': 'Black', '#8B0000': 'Dark Red', '#003366': 'Navy',
        '#2D572C': 'Forest Green', '#4B0082': 'Indigo',
        '#FF0000': 'Red', '#FF6600': 'Orange', '#1E90FF': 'Dodger Blue',
        '#FF1493': 'Hot Pink', '#32CD32': 'Lime Green'
      };

      var AVAILABLE_FONTS = [
        { key: 'Oswald',          label: 'Oswald' },
        { key: 'Montserrat',      label: 'Montserrat' },
        { key: 'Nunito',          label: 'Nunito' },
        { key: 'RobotoBlack',     label: 'Roboto Black' },
        { key: 'PlayfairDisplay', label: 'Playfair Display' },
        { key: 'Merriweather',    label: 'Merriweather' },
        { key: 'Bitter',          label: 'Bitter' },
        { key: 'Exo2',            label: 'Exo 2' },
        { key: 'Comfortaa',       label: 'Comfortaa' },
        { key: 'Raleway',         label: 'Raleway' }
      ];

      var FONT_WEIGHTS = {
        'Oswald': '500', 'Montserrat': '900', 'Nunito': '900',
        'RobotoBlack': '900', 'PlayfairDisplay': '700',
        'Merriweather': '900', 'Bitter': '700',
        'Exo2': '900', 'Comfortaa': '700', 'Raleway': '900'
      };

      // Stored for font switching — re-runs autoFit with new font
      var rawCleanedSvg = null;
      var storedZones = [];
      var storedDisplayText = '';
      var initialBaseSvg = null; // First render's SVG — preserves stamp shape

      async function rebuildWithFont(fontKey) {
        if (!rawCleanedSvg) return baseSvg;
        var weight = FONT_WEIGHTS[fontKey] || '400';

        // Start from raw template, replace font-family + weight
        var svg = rawCleanedSvg.replace(/font-family=["']'?[^"']*'?["']/g,
          "font-family=\"'" + fontKey + "'\"");
        svg = svg.replace(/font-weight=["'][^"']*["']/g,
          'font-weight="' + weight + '"');

        // Replace text + auto-fit (same logic as initial load)
        var didAutoFit = false;
        for (var i = 0; i < storedZones.length; i++) {
          var zone = storedZones[i];
          var idx = zone.svg_element_index || 0;
          svg = SvgRenderer.replaceTextInString(svg, idx, storedDisplayText);

          if (zone.bounding_width) {
            var originalScaleX = zone.transform_matrix
              ? parseFloat(zone.transform_matrix.match(/matrix\(\s*([\d.]+)/)?.[1]) || 1
              : 1;
            svg = await SvgRenderer.autoFitTextInString(
              svg, idx, zone.bounding_width,
              zone.font_size, originalScaleX
            );
            didAutoFit = true;
          }
        }

        // Category 2 (Fixed Frame): always auto-fit using container rect
        if (!didAutoFit && /<image[\s>]/i.test(svg)) {
          svg = await SvgRenderer.autoFitTextInString(svg, 0, 1, 128, 1);
        }

        // Category 1 (Dynamic Frame): preserve initial stamp shape
        var isCat1 = !/<image[\s>]/i.test(svg);
        if (isCat1) {
          if (!initialBaseSvg) {
            // First render — store as the reference shape
            initialBaseSvg = svg;
          } else {
            // Transplant autoFit text into initial stamp shape
            var autoFitTexts = [];
            svg.replace(/<text[\s\S]*?<\/text>/gi, function(m) {
              autoFitTexts.push(m);
            });

            // Calculate Y offset to re-center text in the (taller) initial viewBox
            function vbCenter(s) {
              var m = s.match(/viewBox=["']\s*([\d.\-]+)\s+([\d.\-]+)\s+([\d.\-]+)\s+([\d.\-]+)/);
              if (!m) return null;
              return {
                x: parseFloat(m[1]) + parseFloat(m[3]) / 2,
                y: parseFloat(m[2]) + parseFloat(m[4]) / 2
              };
            }
            var cAuto = vbCenter(svg);
            var cInit = vbCenter(initialBaseSvg);

            if (cAuto && cInit) {
              var dx = cInit.x - cAuto.x;
              var dy = cInit.y - cAuto.y;
              if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {
                for (var j = 0; j < autoFitTexts.length; j++) {
                  autoFitTexts[j] = autoFitTexts[j].replace(
                    /transform=["']translate\(\s*([\d.\-]+)[,\s]+([\d.\-]+)\s*\)["']/,
                    function(_, tx, ty) {
                      return 'transform="translate(' +
                        (parseFloat(tx) + dx).toFixed(2) + ', ' +
                        (parseFloat(ty) + dy).toFixed(2) + ')"';
                    }
                  );
                }
              }
            }

            // Splice autoFit text into the initial stamp shape
            var ti = 0;
            svg = initialBaseSvg.replace(/<text[\s\S]*?<\/text>/gi, function() {
              return autoFitTexts[ti++] || '';
            });
          }
        }

        return svg;
      }

      var DOWNLOAD_SIZES = {
        'jpg-small':  { maxSize: 500,  scale: 1, format: 'jpeg', ext: 'jpg' },
        'jpg-medium': { maxSize: 1000, scale: 1, format: 'jpeg', ext: 'jpg' },
        'jpg-large':  { maxSize: 1000, scale: 3, format: 'jpeg', ext: 'jpg' },
        'png-small':  { maxSize: 500,  scale: 1, format: 'png',  ext: 'png' },
        'png-medium': { maxSize: 1000, scale: 1, format: 'png',  ext: 'png' },
        'png-large':  { maxSize: 1000, scale: 3, format: 'png',  ext: 'png' }
      };

      // ---- State ----
      var baseSvg = null;
      var currentSvg = null;
      var templateName = '';
      var templateBorderType = null;
      var templateFillType = 'full';
      var templateCornerType = null;
      var templateObjectType = 'stamp';
      var userText = '';
      var currentColor = '';
      var currentFont = '';
      var currentTilt = 0;
      var currentTexture = '';
      var currentFrame = 'single';
      var borderInfo = null;
      var isProcessing = false;

      // ---- Parse URL params ----
      var params = new URLSearchParams(window.location.search);
      var templateId = params.get('id');
      userText = params.get('text') || '';
      var colorParam = (params.get('color') || '').toUpperCase();
      currentColor = colorParam ? '#' + colorParam : '';
      currentFont = params.get('font') || '';
      currentTilt = parseInt(params.get('tilt'), 10) || 0;
      currentTexture = params.get('texture') || '';
      currentFrame = params.get('frame') || 'single';

      if (!templateId) {
        document.getElementById('product-preview').innerHTML =
          '<div class="stamp-empty">No template ID provided. <a href="/">Go back</a></div>';
        return;
      }

      // Back link preserves text
      document.getElementById('product-back').href = '/?text=' + encodeURIComponent(userText);

      // ---- Fetch template ----
      var { data: tpl, error } = await sb
        .from('templates')
        .select('*, text_zones(*)')
        .eq('id', templateId)
        .eq('is_active', true)
        .single();

      if (error || !tpl) {
        document.getElementById('product-preview').innerHTML =
          '<div class="stamp-empty">Could not load this template. <a href="/">Go back</a></div>';
        return;
      }

      templateName = tpl.name;
      templateBorderType = tpl.border_type || null;
      templateFillType = tpl.fill_type || 'full';
      templateCornerType = tpl.corner_type || null;
      templateObjectType = tpl.object_type || 'stamp';
      document.title = 'StampaText - ' + templateName;

      // ---- Fetch SVG from storage ----
      var storageBaseUrl = sb.storage.from('templates').getPublicUrl('').data.publicUrl;
      var svgUrl = storageBaseUrl.replace(/\/$/, '') + '/' + tpl.svg_path;
      var rawSvg = await SvgRenderer.fetchSvg(svgUrl);
      var cleanedSvg = SvgRenderer.cleanSvgString(rawSvg);

      // ---- Detect text case from original SVG ----
      var displayText = userText;
      (function() {
        var textMatch = cleanedSvg.match(/<text[^>]*>([\s\S]*?)<\/text>/i);
        if (textMatch) {
          var inner = textMatch[1].replace(/<[^>]*>/g, '');
          inner = inner.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"');
          var letters = inner.replace(/[^a-zA-Z]/g, '');
          if (letters.length > 0) {
            var upper = letters.replace(/[^A-Z]/g, '').length;
            var lower = letters.replace(/[^a-z]/g, '').length;
            if (upper > 0 && lower === 0) displayText = userText.toUpperCase();
            else if (lower > 0 && upper === 0) displayText = userText.toLowerCase();
          }
        }
      })();

      // ---- Store raw template for font switching ----
      storedZones = (tpl.text_zones || [])
        .filter(function(z) { return z.is_editable; })
        .sort(function(a, b) { return a.sort_order - b.sort_order; });
      storedDisplayText = displayText;
      rawCleanedSvg = cleanedSvg;

      // ---- Detect font + color, then build initial baseSvg via autoFit ----

      // Detect current font from SVG if not in URL
      if (!currentFont) {
        var fontMatch = cleanedSvg.match(/font-family=["']'?([^"']+)'?["']/);
        if (fontMatch) currentFont = fontMatch[1];
      }
      // Default to Oswald if not recognized
      if (!AVAILABLE_FONTS.some(function(f) { return f.key === currentFont; })) {
        currentFont = 'Oswald';
      }

      // If no color in URL, use first palette color
      if (!currentColor || PALETTE_COLORS.indexOf(currentColor) === -1) {
        currentColor = '#000000';
      }

      // Initial render: run autoFit with selected font
      baseSvg = await rebuildWithFont(currentFont);

      // ---- Build UI ----
      buildFontPicker();
      buildColorPalette();
      setToggleState('product-frame-toggle', currentFrame);
      setToggleState('product-tilt-toggle', String(currentTilt));
      setToggleState('product-texture-toggle', currentTexture);
      await renderPreview();

      // ---- Event listeners ----

      // Font picker
      document.getElementById('product-font-picker').addEventListener('click', function(e) {
        var btn = e.target.closest('.font-picker-btn');
        if (!btn) return;
        this.querySelectorAll('.font-picker-btn').forEach(function(b) {
          b.classList.remove('active');
        });
        btn.classList.add('active');
        currentFont = btn.dataset.font;
        renderPreview();
      });

      // Color palette: single-select
      document.getElementById('product-color-palette').addEventListener('click', function(e) {
        var swatch = e.target.closest('.color-swatch');
        if (!swatch) return;
        this.querySelectorAll('.color-swatch').forEach(function(s) {
          s.classList.remove('selected');
        });
        swatch.classList.add('selected');
        currentColor = swatch.dataset.color;
        renderPreview();
      });

      // Frame toggle
      document.getElementById('product-frame-toggle').addEventListener('click', function(e) {
        var btn = e.target.closest('.product-toggle-btn');
        if (!btn) return;
        this.querySelectorAll('.product-toggle-btn').forEach(function(b) {
          b.classList.remove('active');
        });
        btn.classList.add('active');
        currentFrame = btn.dataset.value || 'single';
        renderPreview();
      });

      // Tilt toggle
      document.getElementById('product-tilt-toggle').addEventListener('click', function(e) {
        var btn = e.target.closest('.product-toggle-btn');
        if (!btn) return;
        this.querySelectorAll('.product-toggle-btn').forEach(function(b) {
          b.classList.remove('active');
        });
        btn.classList.add('active');
        currentTilt = parseInt(btn.dataset.value, 10) || 0;
        renderPreview();
      });

      // Texture toggle
      document.getElementById('product-texture-toggle').addEventListener('click', function(e) {
        var btn = e.target.closest('.product-toggle-btn');
        if (!btn) return;
        this.querySelectorAll('.product-toggle-btn').forEach(function(b) {
          b.classList.remove('active');
        });
        btn.classList.add('active');
        currentTexture = btn.dataset.value || '';
        renderPreview();
      });

      // Download modal open
      document.getElementById('btn-download-options').addEventListener('click', function() {
        document.getElementById('download-modal').classList.add('active');
      });

      // Download modal close
      document.getElementById('download-modal-close').addEventListener('click', function() {
        document.getElementById('download-modal').classList.remove('active');
      });

      // Click outside modal to close
      document.getElementById('download-modal').addEventListener('click', function(e) {
        if (e.target === this) this.classList.remove('active');
      });

      // Download confirm
      document.getElementById('btn-download-confirm').addEventListener('click', handleDownload);

      // ---- Helper functions ----

      function isColorDark(hex) {
        var c = hex.replace('#', '');
        var r = parseInt(c.substring(0, 2), 16);
        var g = parseInt(c.substring(2, 4), 16);
        var b = parseInt(c.substring(4, 6), 16);
        return (r * 0.299 + g * 0.587 + b * 0.114) < 150;
      }

      function buildFontPicker() {
        var picker = document.getElementById('product-font-picker');
        AVAILABLE_FONTS.forEach(function(font) {
          var btn = document.createElement('button');
          btn.className = 'font-picker-btn';
          btn.dataset.font = font.key;
          btn.style.fontFamily = "'" + font.key + "', 'Arial Black', sans-serif";
          btn.textContent = font.label.toUpperCase();
          if (font.key === currentFont) btn.classList.add('active');
          picker.appendChild(btn);
        });
      }

      function buildColorPalette() {
        var palette = document.getElementById('product-color-palette');
        PALETTE_COLORS.forEach(function(color) {
          var swatch = document.createElement('div');
          swatch.className = 'color-swatch';
          if (isColorDark(color)) swatch.classList.add('swatch-dark');
          swatch.style.backgroundColor = color;
          swatch.dataset.color = color;
          if (color === '#FFFFFF') {
            swatch.style.border = '2px solid #d4d4d4';
          }
          if (color.toUpperCase() === currentColor.toUpperCase()) {
            swatch.classList.add('selected');
          }
          palette.appendChild(swatch);
        });
      }

      function setToggleState(containerId, value) {
        var container = document.getElementById(containerId);
        container.querySelectorAll('.product-toggle-btn').forEach(function(btn) {
          btn.classList.toggle('active', btn.dataset.value === value);
        });
      }

      function detectBorderType(svgStr) {
        var rects = [];
        var re = /<rect([^>]*)\/?>/gi;
        var m;
        while ((m = re.exec(svgStr)) !== null) {
          var attrs = m[1];
          if (/fill=["'](?:#FFF(?:FFF)?|white)["']/i.test(attrs)) {
            var hasColoredStroke = /stroke=["'](?!none|#FFF|#FFFFFF|white)#?[A-Fa-f0-9]+["']/i.test(attrs);
            if (!hasColoredStroke) continue;
          }
          var wM = attrs.match(/\swidth=["']([\d.]+)["']/);
          if (!wM) continue;
          rects.push({ attrs: attrs, w: parseFloat(wM[1]) });
        }
        rects.sort(function(a, b) { return b.w - a.w; });
        var origFill = null, origStroke = null, origStrokeWidth = null;
        if (rects.length > 0) {
          var outerAttrs = rects[0].attrs;
          var fM = outerAttrs.match(/\bfill=["']([^"']+)["']/);
          var sM = outerAttrs.match(/\bstroke=["']([^"']+)["']/);
          var swM = outerAttrs.match(/stroke-width=["']([\d.]+)["']/);
          origFill = fM ? fM[1] : null;
          origStroke = sM ? sM[1] : null;
          origStrokeWidth = swM ? parseFloat(swM[1]) : null;
        }
        var wavyM = svgStr.match(/data-wavy=["']([^"']+)["']/);
        var borderM = svgStr.match(/data-border=["']([^"']+)["']/);
        var stitchM = svgStr.match(/data-stitch=["']([^"']+)["']/);
        var brushM = svgStr.match(/data-brush-border=["']([^"']+)["']/);
        var filterM = svgStr.match(/data-filter=["']([^"']+)["']/);
        var brushCoords = null, brushContent = null;
        if (brushM) {
          brushCoords = brushM[1].split(',').map(Number);
          var bgM = svgStr.match(/<g[^>]*data-brush-border=["'][^"']*["'][^>]*>([\s\S]*?)<\/g>/);
          if (bgM) brushContent = bgM[1].trim();
        }
        return {
          wavy: wavyM ? wavyM[1] : null,
          border: borderM ? borderM[1] : null,
          stitch: stitchM ? stitchM[1] : null,
          brush: !!brushM,
          brushCoords: brushCoords,
          brushContent: brushContent,
          filter: filterM ? filterM[1] : null,
          origFill: origFill,
          origStroke: origStroke,
          origStrokeWidth: origStrokeWidth
        };
      }

      function addDoubleFrame(svgStr, bi) {
        bi = bi || {};
        var isCat1Border = bi.wavy || bi.brush || bi.stitch || bi.border || bi.filter;
        if (!isCat1Border && /<image[\s>]/i.test(svgStr)) return svgStr;
        var rects = [];
        var re = /<rect([^>]*)\/?>/gi;
        var m;
        while ((m = re.exec(svgStr)) !== null) {
          var attrs = m[1];
          if (/fill=["'](?:#FFF(?:FFF)?|white)["']/i.test(attrs)) {
            var hasColoredStroke = /stroke=["'](?!none|#FFF|#FFFFFF|white)#?[A-Fa-f0-9]+["']/i.test(attrs);
            if (!hasColoredStroke) continue;
          }
          if (/display=["']none["']/i.test(attrs)) continue;
          var wM = attrs.match(/\swidth=["']([\d.]+)["']/);
          var hM = attrs.match(/\sheight=["']([\d.]+)["']/);
          if (!wM || !hM) continue;
          rects.push({ full: m[0], attrs: attrs, w: parseFloat(wM[1]), h: parseFloat(hM[1]), index: m.index });
        }
        if (rects.length === 0) return svgStr;
        rects.sort(function(a, b) { return b.w - a.w; });
        var outer = rects[0];
        if (rects.length > 1 && rects[1].w > outer.w * 0.9) {
          var second = rects[1];
          if (/fill=["']none["']/i.test(second.attrs) && /stroke=["']#(?:FFF(?:FFF)?|FFFFFF)["']/i.test(second.attrs)) {
            return svgStr;
          }
        }
        var xM = outer.attrs.match(/\bx=["']([\d.\-]+)["']/);
        var yM = outer.attrs.match(/\by=["']([\d.\-]+)["']/);
        var swM = outer.attrs.match(/stroke-width=["']([\d.]+)["']/);
        var rxM = outer.attrs.match(/\brx=["']([\d.]+)["']/);
        var ryM = outer.attrs.match(/\bry=["']([\d.]+)["']/);
        var ox = xM ? parseFloat(xM[1]) : 0;
        var oy = yM ? parseFloat(yM[1]) : 0;
        var ow = outer.w, oh = outer.h;
        var osw = swM ? parseFloat(swM[1]) : (bi.origStrokeWidth || 20);
        if (osw === 0 && bi.origStrokeWidth) osw = bi.origStrokeWidth;
        var orx = rxM ? parseFloat(rxM[1]) : 0;
        var ory = ryM ? parseFloat(ryM[1]) : 0;
        var fillM = outer.attrs.match(/\bfill=["']([^"']+)["']/);
        var outerFill = fillM ? fillM[1] : 'none';
        var strokeM = outer.attrs.match(/\bstroke=["']([^"']+)["']/);
        var outerStroke = strokeM ? strokeM[1] : '#000000';
        if (outerFill === 'none' && bi.wavy && bi.origFill && bi.origFill !== 'none') outerFill = bi.origFill;
        if ((!strokeM || outerStroke === 'none') && bi.origStroke) outerStroke = bi.origStroke;
        var isFull = outerFill !== 'none' && !/^#(?:FFF(?:FFF)?|FFFFFF)$/i.test(outerFill);
        var innerColor;
        if (isFull) {
          var hex = outerFill.replace('#', '');
          var r = parseInt(hex.substring(0, 2), 16);
          var g = parseInt(hex.substring(2, 4), 16);
          var b = parseInt(hex.substring(4, 6), 16);
          var lum = 0.299 * r + 0.587 * g + 0.114 * b;
          innerColor = lum > 160 ? '#000000' : '#FFFFFF';
        } else {
          innerColor = outerStroke;
          if (!innerColor || innerColor === 'none' || /^#(?:FFF(?:FFF)?|FFFFFF)$/i.test(innerColor)) {
            innerColor = bi.origFill && bi.origFill !== 'none' ? bi.origFill : '#000000';
          }
        }
        var innerSw = 12;
        var inset = osw / 2;
        if (bi.stitch && !isFull) inset = 12;
        if (bi.brush) inset = Math.max(inset, Math.min(ow, oh) * 0.12);
        if (bi.filter && !isFull) inset = Math.max(inset, osw * 0.95);
        if (!isFull && !bi.wavy && !bi.brush && !bi.stitch && !bi.filter) {
          inset = osw / 2 + innerSw / 2 + 12;
        }
        var ix = ox + inset, iy = oy + inset;
        var iw = ow - inset * 2, ih = oh - inset * 2;
        var irx = Math.max(0, orx - inset), iry = Math.max(0, ory - inset);
        var innerRect;
        if (bi.wavy) {
          var wavyRe = /<path[^>]*stroke-linejoin="round"[^>]*\/?>/gi;
          var wavyAll = svgStr.match(wavyRe);
          if (wavyAll) {
            innerRect = wavyAll[wavyAll.length - 1]
              .replace(/fill="[^"]*"/, 'fill="none"')
              .replace(/stroke="[^"]*"/, 'stroke="#FFFFFF"')
              .replace(/stroke-width="[^"]*"/, 'stroke-width="12"');
          } else {
            return svgStr;
          }
        } else {
          innerRect = '<rect x="' + ix.toFixed(2) + '" y="' + iy.toFixed(2) +
            '" width="' + iw.toFixed(2) + '" height="' + ih.toFixed(2) +
            '" fill="none" stroke="' + innerColor + '" stroke-width="' + innerSw +
            '" stroke-miterlimit="10"';
          if (irx > 0) innerRect += ' rx="' + irx.toFixed(1) + '"';
          if (iry > 0) innerRect += ' ry="' + iry.toFixed(1) + '"';
          innerRect += '/>';
        }
        var textPos = svgStr.search(/<text[\s>]/i);
        if (textPos !== -1) return svgStr.slice(0, textPos) + innerRect + svgStr.slice(textPos);
        return svgStr.replace(/<\/svg>/, innerRect + '</svg>');
      }

      async function renderPreview() {
        if (isProcessing) return;
        isProcessing = true;

        var previewEl = document.getElementById('product-preview');
        previewEl.style.opacity = '0.5';

        try {
          // Rebuild from raw template with current font (autoFit handles sizing)
          baseSvg = await rebuildWithFont(currentFont);
          var svg = baseSvg;
          svg = SvgRenderer.colorize(svg, currentColor);
          svg = await SvgRenderer.cropViewBoxFixedFrame(svg);
          if (currentFrame === 'double') {
            if (!borderInfo) borderInfo = detectBorderType(rawCleanedSvg);
            svg = addDoubleFrame(svg, borderInfo);
          }
          // Capture pre-tilt viewBox width for scale compensation
          var preTiltVbW = 0;
          var preTiltMatch = svg.match(/viewBox=["']\s*[\d.\-]+\s+[\d.\-]+\s+([\d.\-]+)\s+[\d.\-]+\s*["']/);
          if (preTiltMatch) preTiltVbW = parseFloat(preTiltMatch[1]);

          if (currentTilt !== 0) {
            svg = SvgRenderer.applyTilt(svg, currentTilt);
          }
          if (currentTexture) {
            svg = await SvgRenderer.applyTexture(svg, currentTexture);
          }

          currentSvg = svg;

          previewEl.innerHTML = '';
          var img = SvgRenderer.createSvgImage(svg);

          // Compensate for viewBox expansion from tilt so preview stays same visual size
          if (currentTilt !== 0 && preTiltVbW > 0) {
            var postTiltMatch = svg.match(/viewBox=["']\s*[\d.\-]+\s+[\d.\-]+\s+([\d.\-]+)\s+[\d.\-]+\s*["']/);
            if (postTiltMatch) {
              var postTiltVbW = parseFloat(postTiltMatch[1]);
              var scaleFactor = postTiltVbW / preTiltVbW;
              img.querySelector('svg').style.transform = 'scale(' + scaleFactor.toFixed(4) + ')';
            }
          }
          previewEl.appendChild(img);

          updateDescription();
          updateUrl();
        } catch (err) {
          console.error('Preview render error:', err);
        } finally {
          previewEl.style.opacity = '1';
          isProcessing = false;
        }
      }

      var BORDER_LABELS = {
        wavy: 'wavy', brushstroke: 'brushstroke',
        stitch_line: 'stitch line', stitch_square: 'stitch square', stitch_circle: 'stitch dot',
        torn_edge: 'torn edge', perforated_spaced: 'spaced perforated',
        perforated: 'perforated', zigzag: 'zigzag'
      };

      function updateDescription() {
        var colorName = getColorName(currentColor);
        var border = BORDER_LABELS[templateBorderType] || 'simple';
        var fill = (templateFillType === 'empty') ? 'outlined' : '';
        var texture = (currentTexture === 'grungy_texture') ? 'grungy' : '';
        var tilt = (currentTilt && currentTilt !== 0) ? 'tilted' : '';
        var obj = (templateObjectType || 'stamp').replace(/_/g, ' ');
        var corners = '';
        if (templateCornerType === 'strong_round') corners = 'rounded corners';
        else if (templateCornerType === 'soft_round') corners = 'soft corners';
        var adjectives = [texture, tilt, border, fill].filter(Boolean).join(' ');
        var objPhrase = (adjectives ? adjectives + ' ' : '') + obj;
        var withParts = [corners].filter(Boolean);
        var withClause = withParts.length ? ' with ' + withParts.join(' and ') : '';
        var desc = '\u201C' + displayText + '\u201D written on ' +
          colorName.toLowerCase() + ' ' + objPhrase + withClause;
        document.getElementById('product-description').textContent = desc;
      }

      function updateUrl() {
        var newUrl = '/product.html?id=' + encodeURIComponent(templateId) +
          '&text=' + encodeURIComponent(userText) +
          '&color=' + encodeURIComponent(currentColor.replace('#', '')) +
          '&font=' + encodeURIComponent(currentFont) +
          '&frame=' + encodeURIComponent(currentFrame) +
          '&tilt=' + encodeURIComponent(currentTilt) +
          (currentTexture ? '&texture=' + encodeURIComponent(currentTexture) : '');
        window.history.replaceState(null, '', newUrl);
      }

      function getColorName(hex) {
        return COLOR_NAMES[(hex || '').toUpperCase()] || hex;
      }

      async function handleDownload() {
        var selected = document.querySelector('input[name="download-choice"]:checked');
        if (!selected) {
          alert('Please select a download size.');
          return;
        }

        var choice = selected.value;
        var config = DOWNLOAD_SIZES[choice];
        if (!config || !currentSvg) return;

        var btn = document.getElementById('btn-download-confirm');
        btn.disabled = true;
        btn.textContent = 'Preparing...';

        try {
          var blob = await SvgRenderer.exportImage(
            currentSvg, config.maxSize, null, config.scale, config.format
          );
          var filename = 'stampatext-' + Date.now() + '.' + config.ext;
          SvgRenderer.downloadBlob(blob, filename);

          document.getElementById('download-modal').classList.remove('active');
        } catch (err) {
          console.error('Download error:', err);
          alert('Download failed: ' + err.message);
        } finally {
          btn.disabled = false;
          btn.textContent = 'Download';
        }
      }

    })();
  </script>

</body>
</html>
